<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Figure Proportion Checker</title>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script> 
  <!-- MediaPipe Tasks Vision -->
  <script type="module">
    import { FaceLandmarker, PoseLandmarker, FilesetResolver } 
      from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.22-rc.20250304/vision_bundle.mjs";
    window.MediapipeVision = { FaceLandmarker, PoseLandmarker, FilesetResolver };
  </script>
  <style> 
    :root{
      --bg:#1e0d33;
      --panel:#2a1647;
      --accent:#7c5cff;
      --text:#f5f3ff;
      --muted:#cfc8ff;
      --ok:#3fbf6f;
      --mid:#ffcc66;
      --bad:#ff6b6b;
      --border:#4a2e79;

      /* group colors */
      --g-head:#59d38b;      /* head + eyes */
      --g-shoulder:#51b8ff;  /* shoulders */
      --g-torso:#ffd166;     /* neck base + crotch */
      --g-hip:#ffa45a;       /* hips */
      --g-feet:#b4b4b4;      /* feet */
    }
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      display:grid; place-items:center;
    }
    .frame{
      width:min(1100px,95vw);
      display:grid; gap:16px; padding:18px;
      background:var(--panel); border:1px solid var(--border);
      border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .header{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
    h1{font-size:clamp(1.1rem,2.5vw,1.6rem); margin:0; letter-spacing:.3px}
    .sub{color:var(--muted); font-size:.95rem}
    .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    input[type=file]{
      appearance:none; border:1px dashed var(--accent); color:var(--text);
      background:transparent; padding:10px 12px; border-radius:10px; cursor:pointer
    }
    .btn{
      background:var(--accent); color:#0a0420; border:none; padding:10px 12px;
      border-radius:10px; cursor:pointer; font-weight:600
    }
    .ghost{ background:transparent; color:var(--muted); border:1px solid var(--border) }
    .toggle{ background:transparent; color:var(--text); border:1px solid var(--border) }
    .grid{ display:grid; grid-template-columns:1.1fr .9fr; gap:16px }
    @media (max-width:900px){ .grid{ grid-template-columns:1fr } }
    .panel{ background:#20103b; border:1px solid var(--border); border-radius:14px; padding:14px }
    .stage-wrap{ display:grid; gap:8px }
    #stage{ border-radius:10px }
    table{ width:100%; border-collapse:collapse }
    th,td{ padding:8px 10px; border-bottom:1px solid #37265f; font-size:.95rem }
    th{ text-align:left; color:var(--muted); font-weight:600 }
    .chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
      font-weight:700; font-size:.95rem; background:#160b2c; border:1px solid var(--border) }
    .tag-ok{ color:var(--ok) } .tag-mid{ color:var(--mid) } .tag-bad{ color:var(--bad) }
    .legend{ display:flex; gap:8px; flex-wrap:wrap; font-size:.9rem; color:var(--muted); align-items:center }
    .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid #0003 }
    .hint{ color:var(--muted); font-size:.9rem }

    .guide{
      margin-top:10px;
      background:#140a29;
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px 12px;
      box-shadow:0 10px 25px rgba(0,0,0,.2);
    }
    .guide h4{ margin:0 0 6px 0; font-size:1rem }
    .guide p{ margin:0; color:var(--muted) }

    .badge{ font-size:.8rem; color:#cbbaff; border:1px solid var(--border); padding:4px 8px; border-radius:999px; background:#160b2c }
    .loading{ opacity:.6; pointer-events:none }
  
    /* Secondary Adult Indicators (buttons) */
    .indicators{ margin-top:12px; display:grid; gap:10px; }
    .indicators h4{ margin:0; font-size:1rem }
    .indicator-row{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .indicator-title{ font-weight:600 }
    .indicator-count{ color:var(--muted); font-weight:600 }
    .indicator-grid{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:8px; }
    @media (min-width:900px){ .indicator-grid{ grid-template-columns: repeat(3, minmax(0,1fr)); } }
    .indicator-btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:8px 10px; border-radius:10px; border:1px solid var(--border);
      background:#160b2c; color:var(--text); cursor:pointer; font-weight:600;
      transition:transform .08s ease, box-shadow .08s ease, background .15s ease;
    }
    .indicator-btn:hover{ background:#1f0e3a; box-shadow:0 6px 16px rgba(0,0,0,.25) }
    .indicator-btn.active, .indicator-btn[aria-pressed="true"]{
      background:var(--accent); color:#0a0420; border-color:transparent;
      box-shadow:0 6px 18px rgba(124,92,255,.45);
    }
    .indicator-note{ color:var(--muted); font-size:.85rem }

  </style>
</head>
<body>
  <div class="frame">
    <div class="header">
      <div>
        <h1>Figure Proportion Checker</h1>
        <div class="sub">Upload an image, place landmarks, and see ratios with the WAPS score.</div>
      </div>
      <div class="controls">
        <span class="badge">v1.22</span>                                                                              <!-- Version number -->
        <input type="file" id="file" accept="image/*" />
        <button class="btn" id="help">Help</button>
        <button class="btn" id="autoSeed">Auto-place landmarks</button>
        <button class="btn toggle" id="feetToggle" aria-pressed="false">Feet visible</button>
        <button class="btn" id="exportPng">Export PNG</button>
        <button class="btn" id="exportJson">Export JSON</button>
      </div>
    </div>

    <div class="grid">
      <div class="panel stage-wrap">
        <div id="stage"></div>
        <div class="hint">Drag the colored dots to exact positions. Use Auto-place to get a starting guess.</div>
      </div>

      <div class="panel">
        <div style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:8px;">
          <div id="score" class="chip">WAPS: N/A</div>
          <div class="legend">
            <span class="dot" style="background:var(--g-head)"></span> Head
            <span class="dot" style="background:var(--g-shoulder)"></span> Shoulders
            <span class="dot" style="background:var(--g-torso)"></span> Torso midline
            <span class="dot" style="background:var(--g-hip)"></span> Hips
            <span class="dot" style="background:var(--g-feet)"></span> Feet
          </div>
        </div>

        <table style="margin-top:10px">
          <thead>
            <tr><th>Metric</th><th>Value</th><th>Score</th></tr>
          </thead>
          <tbody id="results"></tbody>
        </table>


        <!-- Secondary Adult Indicators -->
        <div class="indicators" id="indicators">
          <div class="indicator-row">
            <div class="indicator-title">High-Confidence Indicators (HCIs)</div>
            <div class="indicator-count"><span id="hciCount">0</span>/5</div>
          </div>
          <div class="indicator-grid" id="hciGrid">
            <button class="indicator-btn" data-group="hci" data-key="facial" aria-pressed="false">Facial definition</button>
            <button class="indicator-btn" data-group="hci" data-key="neck" aria-pressed="false">Neck length and definition</button>
            <button class="indicator-btn" data-group="hci" data-key="hands" aria-pressed="false">Hand structure and proportion</button>
            <button class="indicator-btn" data-group="hci" data-key="torso" aria-pressed="false">Torso depth and ribcage volume</button>
            <button class="indicator-btn" data-group="hci" data-key="other" aria-pressed="false">Other clear adult-coding</button>
          </div>
          <div class="indicator-note">If 2 or more are observed add +0.25 to WAPS.</div>

          <div class="indicator-row" style="margin-top:8px">
            <div class="indicator-title">Medium-Confidence Indicators (MCIs)</div>
            <div class="indicator-count"><span id="mciCount">0</span>/5</div>
          </div>
          <div class="indicator-grid" id="mciGrid">
            <button class="indicator-btn" data-group="mci" data-key="tone" aria-pressed="false">Muscle tone and limb length</button>
            <button class="indicator-btn" data-group="mci" data-key="feet" aria-pressed="false">Foot and ankle proportion</button>
            <button class="indicator-btn" data-group="mci" data-key="skin" aria-pressed="false">Skin and surface detail</button>
            <button class="indicator-btn" data-group="mci" data-key="posture" aria-pressed="false">Posture and bearing</button>
            <button class="indicator-btn" data-group="mci" data-key="context" aria-pressed="false">Other contextual adult-coding</button>
          </div>
          <div class="indicator-note">If 3 or more are observed add +0.15 to WAPS.</div>
        </div>


        <div id="steps" style="margin-top:12px; display:grid; gap:8px">
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center">
            <button class="btn ghost" id="prevStep">Previous</button>
            <button class="btn" id="nextStep">Next</button>
            <button class="btn ghost" id="skipStep">Skip</button>
            <div class="hint" id="progress">Step 1 of 14</div>
          </div>

          <div id="guide" class="guide" role="status" aria-live="polite">
            <h4 id="guideTitle">Place head top</h4>
            <p id="guideText">Use the highest point of the skull. Ignore hair volume.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="hint">
      Processing stays on your device. This is a proportion estimator. It is not an age verification tool.
    </div>
  </div>

<script>
/* ---------- Landmarks, groups, and step texts ---------- */
const pointNames = [
  "head_top","chin","head_left","head_right",
  "eye_left","eye_right","shoulder_left","shoulder_right",
  "hip_left","hip_right","neck_base","crotch","foot_left","foot_right"
];

const groups = {
  head: ["head_top","chin","head_left","head_right","eye_left","eye_right"],
  shoulder: ["shoulder_left","shoulder_right"],
  torso: ["neck_base","crotch"],
  hip: ["hip_left","hip_right"],
  feet: ["foot_left","foot_right"]
};

function groupOf(name){
  if(groups.head.includes(name)) return "head";
  if(groups.shoulder.includes(name)) return "shoulder";
  if(groups.torso.includes(name)) return "torso";
  if(groups.hip.includes(name)) return "hip";
  return "feet";
}
function colorOf(name){
  const g = groupOf(name);
  return g==="head" ? getCSS("--g-head")
       : g==="shoulder" ? getCSS("--g-shoulder")
       : g==="torso" ? getCSS("--g-torso")
       : g==="hip" ? getCSS("--g-hip")
       : getCSS("--g-feet");
}
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

const stepHelp = {
  head_top: ["Place head top","Use the highest point of the skull. Ignore hair volume."],
  chin: ["Place chin","Use the lowest point of the chin. If the mouth is open use the bone point."],
  head_left: ["Place left head edge","Touch the widest bony point of the skull, not hair."],
  head_right: ["Place right head edge","Touch the widest bony point of the skull, not hair."],
  eye_left: ["Place left eye center","Aim roughly at the center of the visible iris."],
  eye_right: ["Place right eye center","Aim roughly at the center of the visible iris."],
  shoulder_left: ["Place left shoulder","Use the outermost acromion point."],
  shoulder_right: ["Place right shoulder","Use the outermost acromion point."],
  hip_left: ["Place left hip width","Use the outermost pelvis crest, not fabric."],
  hip_right: ["Place right hip width","Use the outermost pelvis crest, not fabric."],
  neck_base: ["Place neck base","Where the neck meets the torso at the front."],
  crotch: ["Place crotch","The midpoint between legs at the highest visible point."],
  foot_left: ["Place left foot ground","Touch the ground contact point."],
  foot_right: ["Place right foot ground","Touch the ground contact point."]
};

/* ---------- Secondary Adult Indicators ---------- */
const indicatorHelp = {
  hci: {
    facial: ["Facial definition", "Sharp jawlines, pronounced cheekbones, lengthened or pointed chins. Adults rarely have round button-like chins unless intentionally stylized."],
    neck: ["Neck length and definition", "Adults show longer, thicker necks with clearer musculature or an Adam’s apple hint in men. Children tend to have short plug-in necks."],
    hands: ["Hand structure and proportion", "Broader palms, longer fingers, defined knuckles and tendons. Juvenile hands look small, puffy, underdeveloped."],
    torso: ["Torso depth and ribcage volume", "Greater ribcage volume and shoulder blade definition. Flat barrel torsos are youth-coded."],
    other: ["Other clear adult-coding", "Any additional style-stable adult anatomical traits that do not depend on clothing or accessories."]
  },
  mci: {
    tone: ["Muscle tone and limb length", "Proportional musculature, elongated forearms or calves, subtle definition at knees, knuckles, or veins."],
    feet: ["Foot and ankle proportion", "Longer, narrower ankles and distinct arches vs simplified rounded feet used for childlike designs."],
    skin: ["Skin and surface detail", "Light wrinkles at eyes or mouth, pores, and varied shading. Rendering level can affect this."],
    posture: ["Posture and bearing", "Confident stance, open shoulders, balanced weight distribution. Personality may override."],
    context: ["Other contextual adult-coding", "Contextual cues that support adult reading but are not sufficient alone."]
  }
};

function bindIndicatorButtons(){
  const buttons = document.querySelectorAll('.indicator-btn');
  buttons.forEach(btn => {
    btn.addEventListener('mouseenter', () => {
      const g = btn.dataset.group, k = btn.dataset.key;
      const tip = indicatorHelp[g] && indicatorHelp[g][k];
      if(tip){ document.getElementById('guideTitle').textContent = tip[0]; document.getElementById('guideText').textContent = tip[1]; }
    });
    btn.addEventListener('mouseleave', () => {
      // restore current positioning hint
      const key = stepKey(currentStep);
      updateGuide(key);
    });
    btn.addEventListener('click', () => {
      const pressed = btn.getAttribute('aria-pressed') === 'true';
      btn.setAttribute('aria-pressed', String(!pressed));
      btn.classList.toggle('active', !pressed);
      recalc();
    });
  });
}

function indicatorCountsAndBonus(){
  const hciCount = document.querySelectorAll('.indicator-btn[data-group="hci"][aria-pressed="true"]').length;
  const mciCount = document.querySelectorAll('.indicator-btn[data-group="mci"][aria-pressed="true"]').length;
  const hciCountEl = document.getElementById('hciCount');
  const mciCountEl = document.getElementById('mciCount');
  if(hciCountEl) hciCountEl.textContent = hciCount;
  if(mciCountEl) mciCountEl.textContent = mciCount;
  let bonus = 0;
  if(hciCount >= 2) bonus += 0.25;
  if(mciCount >= 3) bonus += 0.15;
  return { hciCount, mciCount, bonus };
}


let stage = new Konva.Stage({ container: 'stage', width: 900, height: 560 });
let layer = new Konva.Layer(); stage.add(layer);
let imgNode = new Konva.Image(); layer.add(imgNode);

const markers = {};
const markerStyleBase = { radius: 6, stroke: '#fff', strokeWidth: 2, draggable: true, shadowColor:'#000', shadowBlur:6, shadowOpacity:.25 };
const haloStyle = { radius: 16, stroke: '#f75ecd', strokeWidth: 1.5, dash:[4,4], opacity: .9, listening: false };
let halo = null;

let currentStep = 0;
let ignoreFeet = false;

function dist(a,b){ return Math.hypot(a.x()-b.x(), a.y()-b.y()); }
function midY(a,b){ return (a+b)/2; }
function fmt(v,isPct=false){ if(Number.isNaN(v)) return 'N/A'; return isPct ? v.toFixed(1)+'%' : v.toFixed(2) }
function stepKey(i){ return pointNames[i] }
function setActiveStepByName(name){
  const idx = pointNames.indexOf(name);
  if(idx < 0) return;
  if(ignoreFeet && (name==="foot_left" || name==="foot_right")) return;
  currentStep = idx;
  updateProgress();
  updateGuide(name);
  highlight(name);
}
function updateProgress(){
  document.getElementById('progress').textContent = `Step ${currentStep+1} of ${pointNames.length}`;
}
function updateGuide(point){
  const [t, p] = stepHelp[point];
  document.getElementById('guideTitle').textContent = t;
  document.getElementById('guideText').textContent = p;
}
function highlight(point){
  if(halo) halo.destroy();
  if(!markers[point]) return;
  halo = new Konva.Circle({ x: markers[point].x(), y: markers[point].y(), ...haloStyle });
  layer.add(halo);
  const tween = new Konva.Tween({ node: halo, radius: 26, opacity:.25, duration:.8, yoyo:true, repeat:Infinity });
  tween.play();
  layer.draw();
}

/* ---------- Calculation and rendering ---------- */
function recalc(){
  const rEl = document.getElementById('results');
  rEl.innerHTML = '';

  if(!markers.head_top || !markers.chin) {
    indicatorCountsAndBonus();
    document.getElementById('score').textContent = 'WAPS: N/A';
    return;
  }

  const headH = dist(markers.head_top, markers.chin);
  const headW = (markers.head_left && markers.head_right) ? dist(markers.head_left, markers.head_right) : NaN;

  const feetY = ignoreFeet
    ? NaN
    : (markers.foot_left && markers.foot_right) ? midY(markers.foot_left.y(), markers.foot_right.y()) : NaN;

  const totalH = Number.isNaN(feetY) ? NaN : Math.abs(markers.head_top.y() - feetY);
  const shoulder = (markers.shoulder_left && markers.shoulder_right) ? dist(markers.shoulder_left, markers.shoulder_right) : NaN;
  const hip = (markers.hip_left && markers.hip_right) ? dist(markers.hip_left, markers.hip_right) : NaN;
  const torso = (markers.neck_base && markers.crotch) ? dist(markers.neck_base, markers.crotch) : NaN;
  const legs = (markers.crotch && !Number.isNaN(feetY)) ? Math.abs(markers.crotch.y() - feetY) : NaN;
  const eyeY = (markers.eye_left && markers.eye_right) ? midY(markers.eye_left.y(), markers.eye_right.y()) : NaN;

  const vals = {
    heads_total: totalH && headH ? totalH / headH : NaN,
    shoulder_head: shoulder && headW ? shoulder / headW : NaN,
    torso_head: torso && headH ? torso / headH : NaN,
    leg_total_pct: legs && totalH ? (legs / totalH) * 100 : NaN,
    eye_in_head_pct: headH && !Number.isNaN(eyeY) ? (Math.abs(eyeY - markers.head_top.y()) / headH) * 100 : NaN,
    hip_shoulder_pct: hip && shoulder ? (hip / shoulder) * 100 : NaN
  };

  const scoreFns = {
    heads_total: v => Number.isNaN(v) ? null : (v >= 7.0 ? 2 : v >= 6.5 ? 1 : 0),
    shoulder_head: v => Number.isNaN(v) ? null : (v >= 2.0 ? 2 : v >= 1.9 ? 1 : 0),
    torso_head: v => Number.isNaN(v) ? null : (v >= 2.5 ? 2 : v >= 2.2 ? 1 : 0),
    leg_total_pct: v => Number.isNaN(v) ? null : (v >= 50 ? 2 : v >= 48 ? 1 : 0),
    eye_in_head_pct: v => Number.isNaN(v) ? null : (v >= 48 && v <= 50 ? 2 : v <= 47 ? 0 : 1),
    hip_shoulder_pct: v => Number.isNaN(v) ? null : (v >= 75 ? 2 : v <= 74 ? 0 : 1)
  };

  const rows = [
    ["Total height in heads", vals.heads_total, scoreFns.heads_total(vals.heads_total), false, "feet"],
    ["Shoulder width / Head width", vals.shoulder_head, scoreFns.shoulder_head(vals.shoulder_head), false, null],
    ["Torso height / Head height", vals.torso_head, scoreFns.torso_head(vals.torso_head), false, null],
    ["Leg length of total height", vals.leg_total_pct, scoreFns.leg_total_pct(vals.leg_total_pct), true, "feet"],
    ["Eye position within head", vals.eye_in_head_pct, scoreFns.eye_in_head_pct(vals.eye_in_head_pct), true, null],
    ["Hip width / Shoulder width", vals.hip_shoulder_pct, scoreFns.hip_shoulder_pct(vals.hip_shoulder_pct), true, null]
  ];

  let sum = 0, n = 0;
  for(const [label,val,sc,isPct,depends] of rows){
    const effectiveVal = (ignoreFeet && depends==="feet") ? NaN : val;
    const effectiveScore = (ignoreFeet && depends==="feet") ? null : sc;
    const tr = document.createElement('tr');
    const cls = effectiveScore===2?'tag-ok': effectiveScore===1?'tag-mid': effectiveScore===0?'tag-bad':'';
    tr.innerHTML = `
      <td>${label}${depends==="feet" && ignoreFeet ? " (ignored)" : ""}</td>
      <td>${fmt(effectiveVal,isPct)}</td>
      <td class="${cls}"><strong>${effectiveScore===null?'N/A':effectiveScore}</strong></td>
    `;
    rEl.appendChild(tr);
    if(effectiveScore!==null){ sum+=effectiveScore; n++; }
  }
  const avg = n ? (sum/n) : null;

// Secondary indicators contribution
const { bonus } = indicatorCountsAndBonus();
const finalAvg = avg===null ? null : Math.min(2, avg + bonus);

const verdict = finalAvg===null ? 'N/A' : (finalAvg>=1.5 ? 'Adult-like' : finalAvg>=1.0 ? 'Ambiguous or adolescent range' : 'Juvenile-proportioned');

const parts = [];
if(finalAvg!==null) parts.push(`WAPS: ${finalAvg.toFixed(2)}`);
if(avg!==null) parts.push(`base ${avg.toFixed(2)}`);
if(avg!==null && bonus>0) parts.push(`indicators +${bonus.toFixed(2)}`);

document.getElementById('score').textContent = parts.length ? `${parts.join(' | ')}  |  ${verdict}` : 'WAPS: N/A';
}

/* ---------- Marker management ---------- */
function addMarker(name, x, y){
  const style = { ...markerStyleBase, fill: colorOf(name) };
  const c = new Konva.Circle({ x, y, ...style });

  const selectThis = () => setActiveStepByName(name);
  c.on('mousedown', selectThis);
  c.on('touchstart', selectThis);
  c.on('dragstart', selectThis);

  c.on('dragmove', () => {
    if(halo){ halo.position(c.position()); layer.batchDraw(); }
    recalc();
  });
  c.on('dragend', recalc);

  layer.add(c); markers[name] = c; layer.draw();
}
function resetMarkers(){
  for(const k in markers){ markers[k].destroy(); delete markers[k]; }
  if(halo){ halo.destroy(); halo=null; }
  layer.draw();
}

/* ---------- Guided navigation ---------- */
function startGuide(){
  currentStep = 0;
  updateProgress();
  const key = stepKey(currentStep);
  updateGuide(key);
  highlight(key);
}
function nextStep(){
  if(currentStep < pointNames.length-1){
    currentStep++;
    if(ignoreFeet && (stepKey(currentStep)==="foot_left" || stepKey(currentStep)==="foot_right")){
      if(currentStep < pointNames.length-1) currentStep++;
    }
    const key = stepKey(currentStep);
    updateProgress();
    updateGuide(key);
    highlight(key);
  }
}
function prevStep(){
  if(currentStep > 0){
    currentStep--;
    if(ignoreFeet && (stepKey(currentStep)==="foot_left" || stepKey(currentStep)==="foot_right")){
      if(currentStep > 0) currentStep--;
    }
    const key = stepKey(currentStep);
    updateProgress();
    updateGuide(key);
    highlight(key);
  }
}

/* ---------- File load ---------- */
document.getElementById('file').addEventListener('change', e=>{
  const file = e.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const img = new Image();
    img.onload = () => {
      resetMarkers();
      const maxW = Math.min(980, window.innerWidth - 80);
      const maxH = 520;
      const scale = Math.min(maxW / img.width, maxH / img.height);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);

      imgNode.image(img); imgNode.width(w); imgNode.height(h);
      stage.size({ width:w, height:h }); layer.draw();

      // seed markers near center
      const cx=w*0.5, cy=h*0.35;
      pointNames.forEach((p,i)=> addMarker(p, cx+(i%2?30:-30), cy+i*6));

      applyFeetVisibility();
      recalc();
      startGuide();
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
});

/* ---------- Export buttons ---------- */
document.getElementById('exportPng').addEventListener('click', ()=>{
  const labels = [];
  Object.entries(markers).forEach(([name, c])=>{
    if(ignoreFeet && (name==="foot_left" || name==="foot_right")) return;
    const t = new Konva.Text({ x: c.x()+8, y: c.y()-14, text: name, fontSize: 10, fill: '#f75ecd' });
    layer.add(t); labels.push(t);
  });
  layer.draw();
  const url = stage.toDataURL({ pixelRatio: 2 });
  labels.forEach(t=> t.destroy()); layer.draw();

  const a = document.createElement('a');
  a.href = url; a.download = 'figure-check.png'; a.click();
});

document.getElementById('exportJson').addEventListener('click', ()=>{
  const data = {};
  Object.entries(markers).forEach(([k,v])=>{
    if(ignoreFeet && (k==="foot_left" || k==="foot_right")) return;
    data[k] = { x: v.x(), y: v.y() };
  });
  const blob = new Blob([JSON.stringify(data, null, 2)], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'landmarks.json'; a.click();
  URL.revokeObjectURL(url);
});

/* ---------- Buttons ---------- */
document.getElementById('help').addEventListener('click', ()=>{
  if(!imgNode.image()){ alert('Load an image first.'); return; }
  startGuide();
});
document.getElementById('nextStep').addEventListener('click', nextStep);
document.getElementById('prevStep').addEventListener('click', prevStep);
document.getElementById('skipStep').addEventListener('click', nextStep);

// Bind indicator buttons
bindIndicatorButtons();

document.getElementById('feetToggle').addEventListener('click', ()=>{
  ignoreFeet = !ignoreFeet;
  applyFeetVisibility();
  recalc();
  if(ignoreFeet && (stepKey(currentStep)==="foot_left" || stepKey(currentStep)==="foot_right")){
    nextStep();
  }
});

/* ---------- Feet visibility ---------- */
function applyFeetVisibility(){
  const btn = document.getElementById('feetToggle');
  btn.setAttribute('aria-pressed', ignoreFeet ? 'true' : 'false');
  btn.textContent = ignoreFeet ? 'Feet not visible' : 'Feet visible';

  const footNames = ["foot_left","foot_right"];
  footNames.forEach(n=>{
    const m = markers[n];
    if(!m) return;
    if(ignoreFeet){
      m.hide();
    } else {
      m.show();
      m.fill(colorOf(n));
    }
  });
  layer.draw();
}

/* ============================================================
   Auto-place landmarks (MediaPipe Face + Pose) — in browser
   ============================================================ */
let faceLandmarker = null;
let poseLandmarker = null;
let vision = null;
let modelsReady = false;

async function ensureModels(){
  if(modelsReady) return;

  const { FaceLandmarker, PoseLandmarker, FilesetResolver } = 
    await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.22-rc.20250304/vision_bundle.mjs");

  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.22-rc.20250304/wasm"
  );

  faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task" },
    runningMode: "IMAGE",
    numFaces: 1
  });

  poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task" },
    runningMode: "IMAGE",
    numPoses: 1
  });

  modelsReady = true;
}


function canvasFromStageImage(){
  if(!imgNode.image()) return null;
  const w = imgNode.width();
  const h = imgNode.height();
  const cv = document.createElement('canvas');
  cv.width = w; cv.height = h;
  const ctx = cv.getContext('2d');
  // draw exactly as shown on stage so coords match
  ctx.drawImage(imgNode.image(), 0, 0, w, h);
  return cv;
}

// Helper to clamp and place a marker safely
function place(name, x, y){
  const w = stage.width(), h = stage.height();
  const px = Math.max(0, Math.min(w, x));
  const py = Math.max(0, Math.min(h, y));
  if(!markers[name]){
    addMarker(name, px, py);
  } else {
    markers[name].position({x:px, y:py});
  }
}

function avgPoint(list){
  const n = list.length;
  if(!n) return [NaN, NaN];
  let x=0,y=0; for(const p of list){ x+=p[0]; y+=p[1]; }
  return [x/n, y/n];
}

document.getElementById('autoSeed').addEventListener('click', async ()=>{
  if(!imgNode.image()){
    alert('Load an image first.');
    return;
  }
  const btn = document.getElementById('autoSeed');
  btn.classList.add('loading');
  btn.textContent = 'Auto-placing…';

  try{
    await ensureModels();
    const cv = canvasFromStageImage();
    if(!cv) throw new Error('No image canvas');

    // Run detectors
    const faceRes = await faceLandmarker.detect(cv);
    const poseRes = await poseLandmarker.detect(cv);

    const w = cv.width, h = cv.height;

    // ---------- Face mapping ----------
    // Use common indices from Face Mesh:
    // 10 = top of forehead region, 152 = chin
    // 33 and 133 approx outer/inner left eye corners, 362 and 263 right
    // 127 = left temple, 356 = right temple
    let fm = null;
    if(faceRes.faceLandmarks && faceRes.faceLandmarks.length){
      fm = faceRes.faceLandmarks[0];
      const px = (i) => [fm[i].x * w, fm[i].y * h];

      const head_top = px(10);
      const chin = px(152);
      const eyeL = avgPoint([px(33), px(133)]);
      const eyeR = avgPoint([px(362), px(263)]);
      const headL = px(127);
      const headR = px(356);

      place('head_top', head_top[0], head_top[1]);
      place('chin', chin[0], chin[1]);
      place('eye_left', eyeL[0], eyeL[1]);
      place('eye_right', eyeR[0], eyeR[1]);
      place('head_left', headL[0], headL[1]);
      place('head_right', headR[0], headR[1]);
    }

    // ---------- Pose mapping ----------
    // Pose indices: 11 L shoulder, 12 R shoulder, 23 L hip, 24 R hip, 27 L ankle, 28 R ankle
    let pm = null;
    if(poseRes.landmarks && poseRes.landmarks.length){
      pm = poseRes.landmarks[0];
      const ppx = (i) => [pm[i].x * w, pm[i].y * h];

      const shL = ppx(11), shR = ppx(12);
      const hipL = ppx(23), hipR = ppx(24);
      const ankL = ppx(27), ankR = ppx(28);

      place('shoulder_left', shL[0], shL[1]);
      place('shoulder_right', shR[0], shR[1]);
      place('hip_left', hipL[0], hipL[1]);
      place('hip_right', hipR[0], hipR[1]);

      // neck_base: midpoint between shoulders, nudged down a bit
      const neckX = (shL[0] + shR[0]) / 2;
      const neckY = (shL[1] + shR[1]) / 2 + (Math.hypot(shL[0]-shR[0], shL[1]-shR[1]) * 0.05);
      place('neck_base', neckX, neckY);

      // crotch: midpoint between hips, nudged down a bit
      const crotchX = (hipL[0] + hipR[0]) / 2;
      const crotchY = (hipL[1] + hipR[1]) / 2 + (Math.hypot(hipL[0]-hipR[0], hipL[1]-hipR[1]) * 0.1);
      place('crotch', crotchX, crotchY);

      // feet: use ankles as ground contact proxy
      place('foot_left', ankL[0], ankL[1]);
      place('foot_right', ankR[0], ankR[1]);
    }

    layer.draw();
    recalc();

    // If we placed at least head_top, set the guide to chin next
    if(markers.head_top){ setActiveStepByName('chin'); }

    // Respect feet toggle
    applyFeetVisibility();

    // Fallback hint if nothing detected
    if(!fm && !pm){
      alert('Auto-place could not detect landmarks. Please position the dots manually and consider images with clearer full body framing.');
    }

  } catch(err){
    console.error(err);
    alert('Auto-place failed to run. This usually happens if the models could not be loaded. Please try again or place the points manually.');
  } finally {
    btn.classList.remove('loading');
    btn.textContent = 'Auto-place landmarks';
  }
}
);
</script>
</body>
</html>


